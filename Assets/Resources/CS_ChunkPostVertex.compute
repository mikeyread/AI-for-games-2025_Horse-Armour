#pragma kernel ChunkPostVertex

RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float3> normals;

uniform uint meshSize;
uniform float quadScale;


float Magnitude(float3 vec)
{
    return sqrt(pow(vec.x, 2) + pow(vec.y, 2) + pow(vec.z, 2));
}


float3 Normalize(float3 vec)
{
    return float3(vec.x / Magnitude(vec), vec.y / Magnitude(vec), vec.z / Magnitude(vec));
}


// Computes Normals using already processed vertex positions.
[numthreads(32,32,1)]
void ChunkPostVertex (uint3 id : SV_DispatchThreadID) {
    uint normalIndex = id.x + (id.y * meshSize);
    
    normals[normalIndex] = float3(0, 1, 0);
    
    // Finds if the normal vertex isn't a part of the Vertex Skirt
    if (normalIndex > meshSize - 1 && normalIndex < meshSize * meshSize - meshSize && normalIndex % meshSize != 0 && (normalIndex + 1) % meshSize != 0)
    {
        float3 UpperTri = cross(vertices[normalIndex + meshSize] - vertices[normalIndex], vertices[normalIndex + 1] - vertices[normalIndex]);
        normals[normalIndex] = UpperTri;
        
        // Find the actual vertex edge of the grid mesh
        if (normalIndex < meshSize * 2 || normalIndex % meshSize == 1)
        {
            //vertices[normalIndex] = float3(vertices[normalIndex].x, vertices[normalIndex].y + 1, vertices[normalIndex].z);
        }
        else if (normalIndex > meshSize * meshSize - meshSize * 2 || normalIndex % meshSize == 0)
        {
            //vertices[normalIndex] = float3(vertices[normalIndex].x, vertices[normalIndex].y + 1, vertices[normalIndex].z);
        }
    }
    else
    {
        vertices[normalIndex] = float3(vertices[normalIndex].x, -250, vertices[normalIndex].z);
    }
}
