#pragma kernel ChunkPostVertex

RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float3> normals;
RWStructuredBuffer<float4> color;

uniform uint meshSize;
uniform float quadScale;

float3 lerpFloat3(float3 lhs, float3 rhs, float lerp)
{
    return lhs + (rhs - lhs) * lerp;
}


float3 minFloat3(float3 lhs, float3 rhs)
{
    return float3(min(lhs.x, rhs.x), min(lhs.y, rhs.y), min(lhs.z, rhs.z));
}

float3 maxFloat3(float3 lhs, float3 rhs)
{
    return float3(max(lhs.x, rhs.x), max(lhs.y, rhs.y), max(lhs.z, rhs.z));
}


[numthreads(32,32,1)]
void ChunkPostVertex (uint3 id : SV_DispatchThreadID) {
    uint vertexIndex = id.x + (id.y * meshSize);
    
    
    // Interpolates colouration based on the respective y offset of each vertex, creating a rudimentary colourmap.
    float3 col = float3(0, 0, 0);
    if (vertices[vertexIndex].y < -1000)
    {
        
        col = lerpFloat3(float3(0.1, 0.45, 0.15), float3(0.11, 0, 1), abs(vertices[vertexIndex].y / 2000));
    }
    else
    {
        col = lerpFloat3(float3(0.1, 0.45, 0.15), float3(0.1, 0.4, 0.3), abs(vertices[vertexIndex].y / 750));
    }
    
    color[vertexIndex] = float4(col, 1);
    
    // Forces the outermost layer of Vertices to create a skirt around the chunk to prevent gaps between LOD's
    if (vertexIndex > meshSize - 1 && vertexIndex < meshSize * meshSize - meshSize && vertexIndex % meshSize != 0 && (vertexIndex + 1) % meshSize != 0)
    {
    }
    else
    {
        vertices[vertexIndex] = float3(vertices[vertexIndex].x, vertices[vertexIndex].y - 250, vertices[vertexIndex].z);
    }
}
