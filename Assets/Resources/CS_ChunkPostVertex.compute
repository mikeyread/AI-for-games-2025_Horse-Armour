#pragma kernel ChunkPostVertex

RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float3> normals;
RWStructuredBuffer<float4> color;

uniform uint meshSize;
uniform float quadScale;

// 
float range(float minVal, float maxVal, float val)
{
    return max(minVal, min(maxVal, val));
}


float3 lerpFloat3(float3 lhs, float3 rhs, float lerp)
{
    return lhs + (rhs - lhs) * range(0, 1, lerp);
}


float3 minFloat3(float3 lhs, float3 rhs)
{
    return float3(min(lhs.x, rhs.x), min(lhs.y, rhs.y), min(lhs.z, rhs.z));
}

float3 maxFloat3(float3 lhs, float3 rhs)
{
    return float3(max(lhs.x, rhs.x), max(lhs.y, rhs.y), max(lhs.z, rhs.z));
}



// Takes values for base colourmap and a Steep colouration, then determines the resulting true Colour based on the Base colourmap and the steep colourmap
// A steepness of zero is pure base Colour, while a steepness of one is pure Steep Colour.
float3 ColorRange(float3 lhsBase, float3 rhsBase, float3 steepCol, float vertY, float steep, float range)
{
    float3 baseCol = lerpFloat3(lhsBase, rhsBase, abs(vertY / range));
    float3 trueCol = lerpFloat3(steepCol, baseCol, steep);
    
    return trueCol;
}


[numthreads(32,32,1)]
void ChunkPostVertex (uint3 id : SV_DispatchThreadID) {
    uint vertexIndex = id.x + (id.y * meshSize);
    
    // Interpolates colouration based on the respective y offset of each vertex, creating a rudimentary colourmap.
    float3 col = float3(0, 0, 0);
    
    if (-1000 <= vertices[vertexIndex].y <= 0)
    {
        col = ColorRange(float3(0.1, 0.45, 0.15), float3(0.11, 0, 1), float3(0, 0, 0.7), vertices[vertexIndex].y, normals[vertexIndex].y, 1000);
    }
    else if (0 <= vertices[vertexIndex].y <= 1500)
    {
        col = ColorRange(float3(0.1, 0.45, 0.15), float3(0.25, 0.25, 0.25), float3(0.5, 0.15, 0.15), vertices[vertexIndex].y, normals[vertexIndex].y, 1500);
    }
    else if (1500 <= vertices[vertexIndex].y <= 2500)
    {
        col = ColorRange(float3(0.15, 0.15, 0.15), float3(1, 1, 1), float3(0.05, 0.05, 0.05), vertices[vertexIndex].y, normals[vertexIndex].y, 2000);
    }
    
    color[vertexIndex] = float4(col, 1);
    
    // Forces the outermost layer of Vertices to create a skirt around the chunk to prevent gaps between LOD's
    if (vertexIndex > meshSize - 1 && vertexIndex < meshSize * meshSize - meshSize && vertexIndex % meshSize != 0 && (vertexIndex + 1) % meshSize != 0)
    {
    
    }
    else
    {
        vertices[vertexIndex] = float3(vertices[vertexIndex].x, vertices[vertexIndex].y - 250, vertices[vertexIndex].z);
    }
}

// RGB red green blue
// HSV hue saturation value
